name: Deploy API to Server

on:
  push:
    branches: [ main ]
    paths:
      - 'backends/api/**'
      - '.github/workflows/deploy-api.yml'
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to Server (No Build Test)
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.7.0
      with:
        ssh-private-key: ${{ secrets.SERVER_SSH_KEY }}
        
    - name: Add server to known hosts
      run: |
        ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
        
    - name: Deploy to server
      env:
        SERVER_HOST: ${{ secrets.SERVER_HOST }}
        SERVER_USER: ${{ secrets.SERVER_USER }}
        DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
        REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        REFRESH_SECRET: ${{ secrets.REFRESH_SECRET }}
      run: |
        ssh $SERVER_USER@$SERVER_HOST << 'EOF'
          set -e
          
          echo "ğŸš€ Starting API deployment..."
          echo "ğŸ“ Note: No test build in GitHub Actions to avoid SQL connection errors"
          echo "ğŸ—ï¸  Building will be done on the server with proper database access"
          
          # í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ë¡œ ì´ë™
          cd /home/admin/projects/mincenter
          
          # ê¸°ì¡´ API ì»¨í…Œì´ë„ˆ ì¤‘ì§€ ë° ì œê±°
          echo "ğŸ›‘ Stopping existing API container..."
          docker compose stop api 2>/dev/null || true
          docker compose rm -f api 2>/dev/null || true
          
          # Gitì—ì„œ ìµœì‹  ì½”ë“œ ê°€ì ¸ì˜¤ê¸°
          echo "ğŸ“¥ Pulling latest code from GitHub..."
          git fetch origin
          git reset --hard origin/main
          git clean -fd
          
          # API ë””ë ‰í† ë¦¬ë¡œ ì´ë™
          cd backends/api
          
          # Dockerfile ìƒì„±
          echo "ğŸ³ Creating Dockerfile..."
          cat > Dockerfile << 'DOCKERFILE_EOF'
        FROM rust:1.75 as builder
        
        WORKDIR /app
        COPY . .
        
        # SQLx CLI ì„¤ì¹˜
        RUN cargo install sqlx-cli --no-default-features --features postgres
        
        # ì˜ì¡´ì„± ìºì‹±ì„ ìœ„í•œ ë”ë¯¸ ë¹Œë“œ
        RUN mkdir -p src && echo "fn main() {}" > src/main.rs
        COPY Cargo.toml Cargo.lock ./
        RUN cargo build --release && rm -rf src
        
        # ì‹¤ì œ ì†ŒìŠ¤ ì½”ë“œ ë³µì‚¬ ë° ë¹Œë“œ
        COPY src ./src
        COPY .sqlx ./.sqlx
        
        # í™˜ê²½ë³€ìˆ˜ ì„¤ì • í›„ ë¹Œë“œ
        ENV SQLX_OFFLINE=true
        RUN cargo build --release --bin mincenter-api
        
        # ëŸ°íƒ€ì„ ì´ë¯¸ì§€
        FROM debian:bookworm-slim
        
        # ëŸ°íƒ€ì„ ì˜ì¡´ì„± ì„¤ì¹˜
        RUN apt-get update && apt-get install -y \
            ca-certificates \
            libssl3 \
            && rm -rf /var/lib/apt/lists/*
        
        WORKDIR /app
        
        # ë¹Œë“œëœ ë°”ì´ë„ˆë¦¬ ë³µì‚¬
        COPY --from=builder /app/target/release/mincenter-api /app/mincenter-api
        
        # ì‹¤í–‰ ê¶Œí•œ ë¶€ì—¬
        RUN chmod +x /app/mincenter-api
        
        # í¬íŠ¸ ë…¸ì¶œ
        EXPOSE 18080
        
        # í™˜ê²½ë³€ìˆ˜ ì„¤ì •
        ENV API_PORT=18080
        ENV RUST_LOG=info
        
        # í—¬ìŠ¤ì²´í¬
        HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
          CMD curl -f http://localhost:18080/health || exit 1
        
        # ì‹¤í–‰ ëª…ë ¹
        CMD ["/app/mincenter-api"]
        DOCKERFILE_EOF
          
          # docker-compose.yml ì—…ë°ì´íŠ¸
          echo "ğŸ“ Updating docker-compose.yml..."
          cd /home/admin/projects/mincenter
          
          # API ì„œë¹„ìŠ¤ê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ê³  ì—†ìœ¼ë©´ ì¶”ê°€
          if ! grep -q "api:" docker-compose.yml; then
            cat >> docker-compose.yml << 'COMPOSE_EOF'

  api:
    build: 
      context: ./backends/api
      dockerfile: Dockerfile
    container_name: mincenter-api
    ports:
      - "18080:18080"
    environment:
      - DATABASE_URL=postgresql://mincenter:${DATABASE_PASSWORD}@postgres:5432/mincenter
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379
      - API_PORT=18080
      - RUST_LOG=info
      - CORS_ORIGIN=https://mincenter.kr,https://admin.mincenter.kr
      - JWT_SECRET=${JWT_SECRET}
      - REFRESH_SECRET=${REFRESH_SECRET}
    depends_on:
      - postgres
      - redis
    networks:
      - mincenter_network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:18080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
        COMPOSE_EOF
          fi
          
          # í™˜ê²½ë³€ìˆ˜ íŒŒì¼ ì—…ë°ì´íŠ¸
          echo "ğŸ”§ Updating environment variables..."
          sed -i "s/POSTGRES_PASSWORD=.*/POSTGRES_PASSWORD=${DATABASE_PASSWORD}/" .env
          sed -i "s/REDIS_PASSWORD=.*/REDIS_PASSWORD=${REDIS_PASSWORD}/" .env
          
          # JWT ì‹œí¬ë¦¿ì´ ì—†ìœ¼ë©´ ì¶”ê°€
          if ! grep -q "JWT_SECRET" .env; then
            echo "JWT_SECRET=${JWT_SECRET}" >> .env
            echo "REFRESH_SECRET=${REFRESH_SECRET}" >> .env
          fi
          
          # Docker ì´ë¯¸ì§€ ë¹Œë“œ ë° ì»¨í…Œì´ë„ˆ ì‹œì‘
          echo "ğŸ—ï¸  Building and starting API container..."
          docker compose build api
          docker compose up -d api
          
          # ì»¨í…Œì´ë„ˆ ì‹œì‘ ëŒ€ê¸°
          echo "â³ Waiting for API container to start..."
          sleep 30
          
          # í—¬ìŠ¤ì²´í¬
          echo "ğŸ¥ Performing health check..."
          for i in {1..10}; do
            if docker exec mincenter-api curl -f http://localhost:18080/health; then
              echo "âœ… API server is healthy!"
              break
            else
              echo "â³ Waiting for API server... ($i/10)"
              sleep 10
            fi
          done
          
          # ì»¨í…Œì´ë„ˆ ìƒíƒœ í™•ì¸
          echo "ğŸ“Š Container status:"
          docker compose ps api
          
          echo "ğŸ‰ API deployment completed successfully!"
        EOF
