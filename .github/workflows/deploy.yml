name: Deploy to Production

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
    types: [ closed ]

# GitHub Container Registry 권한 설정
permissions:
  contents: read
  packages: write
  actions: read

jobs:
  # 환경설정 파일 배포 (최우선 실행)
  deploy-environment:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Deploy environment configuration
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: 22
          script: |
            echo "=== 환경설정 파일 배포 시작 ==="
            cd ${{ secrets.DEPLOY_PATH }}
            
            # .env.production 파일 생성
            cat > .env.production << 'EOF'
            # =============================================================================
            # MinCenter 프로덕션 환경 설정 파일 (GitHub Actions 자동 생성)
            # =============================================================================
            
            # Application Configuration
            APP_NAME=${{ secrets.PROJECT_NAME }}
            NODE_ENV=production
            DOMAIN=${{ secrets.DOMAIN_NAME }}
            
            # Database Configuration
            POSTGRES_DB=${{ secrets.DB_NAME }}
            POSTGRES_USER=${{ secrets.DB_USER }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            POSTGRES_PORT=${{ secrets.POSTGRES_PORT }}
            DATABASE_URL=postgresql://${{ secrets.DB_USER }}:${{ secrets.POSTGRES_PASSWORD }}@localhost:${{ secrets.POSTGRES_PORT }}/${{ secrets.DB_NAME }}
            
            # API Configuration
            API_PORT=${{ secrets.API_PORT }}
            API_URL=https://${{ secrets.API_DOMAIN }}
            PUBLIC_API_URL=https://${{ secrets.API_DOMAIN }}
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            REFRESH_SECRET=${{ secrets.REFRESH_SECRET }}
            ACCESS_TOKEN_EXPIRY_MINUTES=${{ secrets.ACCESS_TOKEN_EXPIRY_MINUTES }}
            REFRESH_TOKEN_EXPIRY_DAYS=${{ secrets.REFRESH_TOKEN_EXPIRY_DAYS }}
            RUST_LOG_LEVEL=${{ secrets.RUST_LOG_LEVEL }}
            
            # CORS Configuration
            CORS_ORIGIN=https://${{ secrets.DOMAIN_NAME }},https://admin.${{ secrets.DOMAIN_NAME }}
            CORS_ALLOWED_ORIGINS=https://${{ secrets.DOMAIN_NAME }},https://admin.${{ secrets.DOMAIN_NAME }},https://${{ secrets.API_DOMAIN }}
            
            # Site Configuration
            SITE_PORT=${{ secrets.SITE_PORT }}
            SESSION_SECRET=${{ secrets.SESSION_SECRET }}
            VITE_API_PORT=${{ secrets.API_PORT }}
            VITE_API_URL=https://${{ secrets.API_DOMAIN }}
            VITE_GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
            VITE_KAKAO_CLIENT_ID=${{ secrets.KAKAO_CLIENT_ID }}
            
            # Admin Configuration
            ADMIN_PORT=${{ secrets.ADMIN_PORT }}
            ADMIN_SESSION_SECRET=${{ secrets.ADMIN_SESSION_SECRET }}
            ADMIN_EMAIL=${{ secrets.ADMIN_EMAIL }}
            
            # Redis Configuration
            REDIS_PORT=${{ secrets.REDIS_PORT }}
            REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
            REDIS_URL=redis://:${{ secrets.REDIS_PASSWORD }}@localhost:${{ secrets.REDIS_PORT }}
            
            # Nginx Configuration
            HTTP_PORT=${{ secrets.HTTP_PORT }}
            HTTPS_PORT=${{ secrets.HTTPS_PORT }}
            
            # SSL Configuration
            SSL_EMAIL=${{ secrets.SSL_EMAIL }}
            
            # Backup Configuration
            BACKUP_SCHEDULE=${{ secrets.BACKUP_SCHEDULE }}
            BACKUP_RETENTION_DAYS=${{ secrets.BACKUP_RETENTION_DAYS }}
            
            # Monitoring Configuration
            MONITORING_ENABLED=${{ secrets.MONITORING_ENABLED }}
            LOG_LEVEL=${{ secrets.LOG_LEVEL }}
            EOF
            
            echo "✅ .env.production 파일 생성 완료"
            
            # 각 서비스 디렉토리에 .env 파일 복사
            echo "=== 각 서비스에 환경설정 파일 배포 ==="
            
            # Site 서비스용 환경설정
            mkdir -p frontends/site
            cat > frontends/site/.env.production << 'EOF'
            NODE_ENV=production
            VITE_API_URL=https://${{ secrets.API_DOMAIN }}
            PUBLIC_API_URL=https://${{ secrets.API_DOMAIN }}
            API_BASE_URL=https://${{ secrets.API_DOMAIN }}
            PUBLIC_DOMAIN=${{ secrets.DOMAIN_NAME }}
            PUBLIC_NODE_ENV=production
            VITE_GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
            VITE_KAKAO_CLIENT_ID=${{ secrets.KAKAO_CLIENT_ID }}
            EOF
            
            # Admin 서비스용 환경설정
            mkdir -p frontends/admin
            cat > frontends/admin/.env.production << 'EOF'
            NODE_ENV=production
            VITE_API_URL=https://${{ secrets.API_DOMAIN }}
            PUBLIC_API_URL=https://${{ secrets.API_DOMAIN }}
            API_BASE_URL=https://${{ secrets.API_DOMAIN }}
            PUBLIC_DOMAIN=${{ secrets.DOMAIN_NAME }}
            PUBLIC_NODE_ENV=production
            EOF
            
            # API 서비스용 환경설정 (Rust는 .env 파일 사용)
            mkdir -p backends/api
            cat > backends/api/.env << 'EOF'
            # API Configuration
            API_PORT=${{ secrets.API_PORT }}
            NODE_ENV=production
            
            # Database Configuration
            DATABASE_URL=postgresql://${{ secrets.DB_USER }}:${{ secrets.POSTGRES_PASSWORD }}@localhost:${{ secrets.POSTGRES_PORT }}/${{ secrets.DB_NAME }}
            POSTGRES_DB=${{ secrets.DB_NAME }}
            POSTGRES_USER=${{ secrets.DB_USER }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            POSTGRES_PORT=${{ secrets.POSTGRES_PORT }}
            
            # Redis Configuration
            REDIS_URL=redis://:${{ secrets.REDIS_PASSWORD }}@localhost:${{ secrets.REDIS_PORT }}
            REDIS_PORT=${{ secrets.REDIS_PORT }}
            REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
            
            # JWT Configuration
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            REFRESH_SECRET=${{ secrets.REFRESH_SECRET }}
            ACCESS_TOKEN_EXPIRY_MINUTES=${{ secrets.ACCESS_TOKEN_EXPIRY_MINUTES }}
            REFRESH_TOKEN_EXPIRY_DAYS=${{ secrets.REFRESH_TOKEN_EXPIRY_DAYS }}
            
            # Logging and CORS
            RUST_LOG_LEVEL=${{ secrets.RUST_LOG_LEVEL }}
            CORS_ORIGIN=https://${{ secrets.DOMAIN_NAME }},https://admin.${{ secrets.DOMAIN_NAME }}
            CORS_ALLOWED_ORIGINS=https://${{ secrets.DOMAIN_NAME }},https://admin.${{ secrets.DOMAIN_NAME }},https://${{ secrets.API_DOMAIN }}
            EOF
            
            echo "✅ 모든 서비스 환경설정 파일 배포 완료"
            echo "=== 배포된 파일 목록 ==="
            ls -la .env.production
            ls -la frontends/site/.env.production
            ls -la frontends/admin/.env.production  
            ls -la backends/api/.env
            echo "=== 환경설정 파일 배포 완료 ==="

  # 데이터베이스 마이그레이션 (환경설정 배포 후 실행)
  migrate-database:
    needs: deploy-environment
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Apply database migrations
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: 22
          script: |
            echo "=== 데이터베이스 마이그레이션 시작 ==="
            cd ${{ secrets.DEPLOY_PATH }}
            
            # database/init.sql 적용 (스키마 변경사항)
            if [ -f database/init.sql ]; then
              echo "Applying database schema updates..."
              docker exec -i mincenter-postgres psql -U mincenter -d mincenter < database/init.sql || echo "Schema update completed with warnings"
            fi
            
            echo "=== 데이터베이스 마이그레이션 완료 ==="

  # 변경 감지
  detect-changes:
    needs: migrate-database
    runs-on: ubuntu-latest
    env:
      DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
      DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
      DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
      DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
    outputs:
      site-changed: ${{ steps.changes.outputs.site }}
      admin-changed: ${{ steps.changes.outputs.admin }}
      api-changed: ${{ steps.changes.outputs.api }}
      env-changed: ${{ steps.changes.outputs.env }}
      db-changed: ${{ steps.changes.outputs.db }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 5  # 최근 5개 커밋과 비교하기 위해

      - name: Detect changes
        id: changes
        run: |
          # 이전 커밋과 비교하여 변경된 파일 감지
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # PR이 머지된 경우
            git fetch origin ${{ github.base_ref }}
            CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)
          else
            # 직접 push된 경우 (최근 3개 커밋 범위로 확장)
            CHANGED_FILES=$(git diff --name-only HEAD~3...HEAD 2>/dev/null || git diff --name-only HEAD~1...HEAD)
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # 각 컴포넌트별 변경 감지
          if echo "$CHANGED_FILES" | grep -q "^frontends/site/"; then
            echo "site=true" >> $GITHUB_OUTPUT
            echo "Site changes detected:"
            echo "$CHANGED_FILES" | grep "^frontends/site/"
          else
            echo "site=false" >> $GITHUB_OUTPUT
            echo "No site changes detected"
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^frontends/admin/"; then
            echo "admin=true" >> $GITHUB_OUTPUT
            echo "Admin changes detected:"
            echo "$CHANGED_FILES" | grep "^frontends/admin/"
          else
            echo "admin=false" >> $GITHUB_OUTPUT
            echo "No admin changes detected"
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^backends/api/"; then
            echo "api=true" >> $GITHUB_OUTPUT
          else
            echo "api=false" >> $GITHUB_OUTPUT
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^\.env"; then
            echo "env=true" >> $GITHUB_OUTPUT
          else
            echo "env=false" >> $GITHUB_OUTPUT
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^database/"; then
            echo "db=true" >> $GITHUB_OUTPUT
          else
            echo "db=false" >> $GITHUB_OUTPUT
          fi

  # 사이트 배포 (Docker 이미지 방식)
  deploy-site:
    needs: detect-changes
    if: needs.detect-changes.outputs.site-changed == 'true'
    runs-on: ubuntu-latest
    env:
      DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
      DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
      DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
      DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Create environment file
        run: |
          cd frontends/site
          cat > .env.production << EOF
          VITE_API_URL=https://${{ secrets.API_DOMAIN }}
          PUBLIC_API_URL=https://${{ secrets.API_DOMAIN }}
          API_BASE_URL=https://${{ secrets.API_DOMAIN }}
          NODE_ENV=production
          PUBLIC_DOMAIN=${{ secrets.DOMAIN_NAME }}
          VITE_GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          VITE_KAKAO_CLIENT_ID=${{ secrets.KAKAO_CLIENT_ID }}
          EOF
          echo "=== 환경변수 파일 생성 완료 ==="
          cat .env.production
      
      - name: Build and push site Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./frontends/site
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/${{ secrets.PROJECT_NAME }}-site:${{ github.sha }}
            ghcr.io/${{ github.repository_owner }}/${{ secrets.PROJECT_NAME }}-site:latest
          build-args: |
            VITE_API_URL=https://${{ secrets.API_DOMAIN }}
            PUBLIC_API_URL=https://${{ secrets.API_DOMAIN }}
            API_BASE_URL=https://${{ secrets.API_DOMAIN }}
            NODE_ENV=production
            PUBLIC_DOMAIN=${{ secrets.DOMAIN_NAME }}
            VITE_GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
            VITE_KAKAO_CLIENT_ID=${{ secrets.KAKAO_CLIENT_ID }}
          cache-from: type=gha
          cache-to: type=gha,mode=min
      
      - name: Clean up Docker resources
        if: always()
        run: |
          echo "=== Docker 정리 시작 ==="
          docker system df
          docker buildx prune -f --keep-storage 2gb
          docker system prune -f
          echo "=== Docker 정리 완료 ==="
          docker system df
      
      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: 22
          script: |
            echo "=== 서버 정보 (FIXED VERSION) ==="
            echo "호스트: $(hostname)"
            echo "IP 주소: $(hostname -I | awk '{print $1}')"
            echo "배포 경로: ${{ secrets.DEPLOY_PATH }}"
            echo "현재 시간: $(date)"
            echo "=================="
            cd ${{ secrets.DEPLOY_PATH }}
            echo "=== 파일 확인 ==="
            ls -la docker-compose*
            echo "=================="
            echo "=== 기존 컨테이너 상태 ==="
            docker compose ps
            echo "========================="
            echo "=== 새 이미지 pull ==="
            docker pull ghcr.io/${{ github.repository_owner }}/${{ secrets.PROJECT_NAME }}-site:${{ github.sha }}
            echo "=== 이미지 pull 완료 ==="
            echo "=== nginx proxy manager 네트워크 확인 ==="
            NPM_NETWORK=$(docker network ls | grep -i nginx | awk '{print $2}' | head -n1)
            if [ -z "$NPM_NETWORK" ]; then
                NPM_NETWORK="nginxproxymanager_default"
                echo "기본 네트워크 이름 사용: $NPM_NETWORK"
            else
                echo "발견된 nginx 네트워크: $NPM_NETWORK"
            fi
            echo
            echo "=== Docker Compose 파일 업데이트 (변수화됨) ==="
            cat > docker-compose.yml << EOF
            
            networks:
              default:
                external: true
                name: ${{ secrets.DOCKER_NETWORK }}
            
            services:
              postgres:
                image: postgres:13-alpine
                container_name: ${{ secrets.PROJECT_NAME }}-postgres
                restart: unless-stopped
                environment:
                  POSTGRES_DB: ${{ secrets.DB_NAME }}
                  POSTGRES_USER: ${{ secrets.DB_USER }}
                  POSTGRES_PASSWORD: "${{ secrets.POSTGRES_PASSWORD }}"
                volumes:
                  - postgres_data:/var/lib/postgresql/data
                  - ./database/init.sql:/docker-entrypoint-initdb.d/01-init.sql
                  - ./database/seed.sql:/docker-entrypoint-initdb.d/02-seed.sql
                ports:
                  - "${{ secrets.POSTGRES_PORT }}:5432"
                healthcheck:
                  test: ["CMD-SHELL", "pg_isready -U ${{ secrets.DB_USER }}"]
                  interval: 10s
                  timeout: 5s
                  retries: 5
            
              redis:
                image: redis:7-alpine
                container_name: ${{ secrets.PROJECT_NAME }}-redis
                restart: unless-stopped
                command: redis-server --requirepass ${{ secrets.REDIS_PASSWORD }}
                volumes:
                  - redis_data:/data
                ports:
                  - "${{ secrets.REDIS_PORT }}:6379"
                healthcheck:
                  test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
                  interval: 10s
                  timeout: 5s
                  retries: 5
            
              site:
                image: ghcr.io/${{ github.repository_owner }}/${{ secrets.PROJECT_NAME }}-site:${{ github.sha }}
                container_name: ${{ secrets.PROJECT_NAME }}-site
                restart: unless-stopped
                depends_on:
                  postgres:
                    condition: service_healthy
                  redis:
                    condition: service_healthy
                ports:
                  - "${{ secrets.SITE_PORT }}:3000"
                environment:
                  - NODE_ENV=production
                  - PUBLIC_API_URL=https://${{ secrets.API_DOMAIN }}
                  - API_BASE_URL=https://${{ secrets.API_DOMAIN }}
                  - PUBLIC_DOMAIN=${{ secrets.DOMAIN_NAME }}
                  - PUBLIC_NODE_ENV=production
                healthcheck:
                  test: ["CMD-SHELL", "curl -f http://localhost:3000 || exit 1"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
            
              admin:
                image: ghcr.io/${{ github.repository_owner }}/${{ secrets.PROJECT_NAME }}-admin:${{ github.sha }}
                container_name: ${{ secrets.PROJECT_NAME }}-admin
                restart: unless-stopped
                depends_on:
                  postgres:
                    condition: service_healthy
                  redis:
                    condition: service_healthy
                ports:
                  - "${{ secrets.ADMIN_PORT }}:3000"
                environment:
                  - NODE_ENV=production
                  - PUBLIC_API_URL=https://${{ secrets.API_DOMAIN }}
                  - PUBLIC_DOMAIN=${{ secrets.DOMAIN_NAME }}
                  - PUBLIC_NODE_ENV=production
                healthcheck:
                  test: ["CMD-SHELL", "curl -f http://localhost:3000 || exit 1"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
            
            volumes:
              postgres_data:
              redis_data:
            EOF
            echo "=== Docker Compose 파일 업데이트 완료 ==="
            echo "=== 기존 컨테이너 완전 제거 ==="
            docker compose down site
            docker compose rm -f site
            echo "=== 기존 컨테이너 제거 완료 ==="
            echo "=== 새 컨테이너 생성 ==="
            docker compose up -d site
            echo "=== 새 컨테이너 생성 완료 ==="
            sleep 5
            echo "=== 배포 후 컨테이너 상태 ==="
            docker compose ps
            echo "============================="
            echo "=== 컨테이너 상태 상세 확인 ==="
            docker compose ps site
            echo "=== Site 컨테이너 로그 확인 (상세) ==="
            docker compose logs --tail=50 site || echo "로그 확인 실패"
            echo "=== Site 컨테이너 상태 검사 ==="
            docker inspect ${{ secrets.PROJECT_NAME }}-site --format='{{.State.Status}}' || echo "컨테이너 상태 확인 실패"
            echo "=== Docker Compose 파일 내용 확인 ==="
            grep -A 15 "site:" docker-compose.yml
            echo "=== 네트워크 연결 확인 ==="
            docker network ls | grep proxy
            echo "===================================="

  # 관리자 배포 (Docker 이미지 방식)
  deploy-admin:
    needs: detect-changes
    if: needs.detect-changes.outputs.admin-changed == 'true'
    runs-on: ubuntu-latest
    env:
      DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
      DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
      DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
      DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Create environment file
        run: |
          cd frontends/admin
          cat > .env.production << EOF
          VITE_API_URL=https://${{ secrets.API_DOMAIN }}
          PUBLIC_API_URL=https://${{ secrets.API_DOMAIN }}
          API_BASE_URL=https://${{ secrets.API_DOMAIN }}
          NODE_ENV=production
          PUBLIC_DOMAIN=${{ secrets.DOMAIN_NAME }}
          EOF
          echo "=== Admin 환경변수 파일 생성 완료 ==="
          cat .env.production
      
      - name: Build and push admin Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./frontends/admin
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/${{ secrets.PROJECT_NAME }}-admin:${{ github.sha }}
            ghcr.io/${{ github.repository_owner }}/${{ secrets.PROJECT_NAME }}-admin:latest
          build-args: |
            VITE_API_URL=https://${{ secrets.API_DOMAIN }}
            PUBLIC_API_URL=https://${{ secrets.API_DOMAIN }}
            API_BASE_URL=https://${{ secrets.API_DOMAIN }}
            NODE_ENV=production
            PUBLIC_DOMAIN=${{ secrets.DOMAIN_NAME }}
          cache-from: type=gha
          cache-to: type=gha,mode=min
      
      - name: Clean up Docker resources (Admin)
        if: always()
        run: |
          echo "=== Admin Docker 정리 시작 ==="
          docker system df
          docker buildx prune -f --keep-storage 2gb
          docker system prune -f
          echo "=== Admin Docker 정리 완료 ==="
          docker system df
      
      - name: Deploy admin to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: 22
          script: |
            echo "=== Admin 서버 정보 (FIXED VERSION) ==="
            echo "호스트: $(hostname)"
            echo "IP 주소: $(hostname -I | awk '{print $1}')"
            echo "배포 경로: ${{ secrets.DEPLOY_PATH }}"
            echo "현재 시간: $(date)"
            echo "=================="
            cd ${{ secrets.DEPLOY_PATH }}
            echo "=== Admin 새 이미지 pull ==="
            docker pull ghcr.io/${{ github.repository_owner }}/${{ secrets.PROJECT_NAME }}-admin:${{ github.sha }}
            echo "=== Admin 이미지 pull 완료 ==="
            echo "=== Admin 컨테이너 업데이트 ==="
            
            # 현재 docker-compose.yml에서 admin 서비스 이미지 태그 업데이트
            sed -i "s|ghcr.io/${{ github.repository_owner }}/${{ secrets.PROJECT_NAME }}-admin:.*|ghcr.io/${{ github.repository_owner }}/${{ secrets.PROJECT_NAME }}-admin:${{ github.sha }}|g" docker-compose.yml
            
            echo "=== Admin 컨테이너 재시작 ==="
            docker compose down admin
            docker compose rm -f admin
            docker compose up -d admin
            echo "=== Admin 컨테이너 재시작 완료 ==="
            sleep 5
            echo "=== Admin 배포 후 컨테이너 상태 ==="
            docker compose ps admin
            echo "=== Admin 컨테이너 로그 확인 ==="
            docker compose logs --tail=20 admin || echo "Admin 로그 확인 실패"
            echo "===================================="