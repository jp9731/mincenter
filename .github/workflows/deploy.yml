name: Deploy to Production

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
    types: [ closed ]

jobs:
  # 변경 감지
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      site-changed: ${{ steps.changes.outputs.site }}
      admin-changed: ${{ steps.changes.outputs.admin }}
      api-changed: ${{ steps.changes.outputs.api }}
      env-changed: ${{ steps.changes.outputs.env }}
      db-changed: ${{ steps.changes.outputs.db }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2  # 이전 커밋과 비교하기 위해

      - name: Detect changes
        id: changes
        run: |
          # 이전 커밋과 비교하여 변경된 파일 감지
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # PR이 머지된 경우
            git fetch origin ${{ github.base_ref }}
            CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)
          else
            # 직접 push된 경우
            CHANGED_FILES=$(git diff --name-only HEAD~1...HEAD)
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # 각 컴포넌트별 변경 감지
          if echo "$CHANGED_FILES" | grep -q "^frontends/site/"; then
            echo "site=true" >> $GITHUB_OUTPUT
          else
            echo "site=false" >> $GITHUB_OUTPUT
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^frontends/admin/"; then
            echo "admin=true" >> $GITHUB_OUTPUT
          else
            echo "admin=false" >> $GITHUB_OUTPUT
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^backends/api/"; then
            echo "api=true" >> $GITHUB_OUTPUT
          else
            echo "api=false" >> $GITHUB_OUTPUT
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^\.env"; then
            echo "env=true" >> $GITHUB_OUTPUT
          else
            echo "env=false" >> $GITHUB_OUTPUT
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^database/"; then
            echo "db=true" >> $GITHUB_OUTPUT
          else
            echo "db=false" >> $GITHUB_OUTPUT
          fi

  # 사이트 배포
  deploy-site:
    needs: detect-changes
    if: needs.detect-changes.outputs.site-changed == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontends/site/package-lock.json
      
      - name: Install dependencies
        run: |
          cd frontends/site
          npm ci
      
      - name: Build site
        run: |
          cd frontends/site
          npm run build
      
      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: 22
          script: |
            # 사이트 파일 전송 (로컬에서 rsync 실행)
            rsync -avz --delete --exclude='node_modules' --exclude='.svelte-kit' \
              ${{ github.workspace }}/frontends/site/ \
              ${{ secrets.DEPLOY_PATH }}/site/
            
            # 컨테이너 재시작
            cd ${{ secrets.DEPLOY_PATH }}
            docker compose restart site

  # 관리자 배포
  deploy-admin:
    needs: detect-changes
    if: needs.detect-changes.outputs.admin-changed == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontends/admin/package-lock.json
      
      - name: Install dependencies
        run: |
          cd frontends/admin
          npm ci
      
      - name: Build admin
        run: |
          cd frontends/admin
          npm run build
      
      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: 22
          script: |
            # 관리자 파일 전송
            rsync -avz --delete --exclude='node_modules' --exclude='.svelte-kit' \
              ${{ github.workspace }}/frontends/admin/ \
              ${{ secrets.DEPLOY_PATH }}/admin/
            
            # 컨테이너 재시작
            cd ${{ secrets.DEPLOY_PATH }}
            docker compose restart admin

  # API 배포
  deploy-api:
    needs: detect-changes
    if: needs.detect-changes.outputs.api-changed == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: x86_64-unknown-linux-gnu
      
      - name: Cache Rust dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            backends/api/target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
      
      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: 22
          script: |
            # API 소스 전송
            rsync -avz --delete \
              ${{ github.workspace }}/backends/api/ \
              ${{ secrets.DEPLOY_PATH }}/api/
            
            # 서버에서 Rust 빌드
            cd ${{ secrets.DEPLOY_PATH }}/api
            cargo build --release
            
            # 바이너리 복사 및 권한 설정
            cp target/release/mincenter-api mincenter-api
            chmod +x mincenter-api
            
            # 컨테이너 재시작
            cd ${{ secrets.DEPLOY_PATH }}
            docker compose restart api

  # 환경 설정 배포
  deploy-env:
    needs: detect-changes
    if: needs.detect-changes.outputs.env-changed == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: 22
          script: |
            # .env 파일 보호 및 백업
            echo "=== .env 파일 보호 시작 ==="
            
            # 백업 디렉토리 생성
            mkdir -p ${{ secrets.DEPLOY_PATH }}/backups
            
            # 기존 .env 파일이 있으면 백업
            if [ -f "${{ secrets.DEPLOY_PATH }}/.env" ]; then
              echo "기존 .env 파일 백업 중..."
              TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
              cp ${{ secrets.DEPLOY_PATH }}/.env ${{ secrets.DEPLOY_PATH }}/backups/.env_backup_${TIMESTAMP}
              gzip ${{ secrets.DEPLOY_PATH }}/backups/.env_backup_${TIMESTAMP}
              echo "백업 완료: .env_backup_${TIMESTAMP}.gz"
            else
              echo "기존 .env 파일이 없습니다."
            fi
            
            # 환경 설정 파일 전송
            echo "새 .env 파일 전송 중..."
            scp ${{ github.workspace }}/.env ${{ secrets.DEPLOY_PATH }}/
            
            # 권한 설정
            chmod 644 ${{ secrets.DEPLOY_PATH }}/.env
            
            # 모든 컨테이너 재시작 (환경변수 변경)
            cd ${{ secrets.DEPLOY_PATH }}
            docker compose restart
            
            echo "=== .env 파일 보호 완료 ==="

  # 데이터베이스 동기화
  deploy-db:
    needs: detect-changes
    if: needs.detect-changes.outputs.db-changed == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client
      
      - name: Database backup
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: 22
          script: |
            echo "=== 데이터베이스 백업 시작 ==="
            
            # 백업 디렉토리 생성
            mkdir -p ${{ secrets.DEPLOY_PATH }}/backups
            
            # 타임스탬프
            TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
            BACKUP_FILE="${{ secrets.DEPLOY_PATH }}/backups/mincenter_backup_${TIMESTAMP}.sql"
            
            # PostgreSQL 백업
            docker exec mincenter-postgres pg_dump -U mincenter -d mincenter > "$BACKUP_FILE"
            
            # 압축
            gzip "$BACKUP_FILE"
            
            echo "백업 완료: ${BACKUP_FILE}.gz"
            
            # 오래된 백업 정리 (7일 이상)
            find ${{ secrets.DEPLOY_PATH }}/backups -name "*.sql.gz" -mtime +7 -delete
            
            echo "=== 백업 완료 ==="
      
      - name: Database synchronization
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: 22
          script: |
            echo "=== 데이터베이스 동기화 시작 ==="
            
            # SQLx 마이그레이션 파일들 전송
            mkdir -p ${{ secrets.DEPLOY_PATH }}/api/database/migrations
            scp ${{ github.workspace }}/backends/api/database/migrations/*.sql ${{ secrets.DEPLOY_PATH }}/api/database/migrations/
            
            # SQLx 마이그레이션 실행
            cd ${{ secrets.DEPLOY_PATH }}/api
            sqlx migrate run --source database/migrations --database-url "postgresql://mincenter:!@swjp0209^^@postgres:5432/mincenter"
            
            # 기존 마이그레이션 파일들도 전송 (하위 호환성)
            mkdir -p ${{ secrets.DEPLOY_PATH }}/database/migrations
            scp ${{ github.workspace }}/database/migrations/*.sql ${{ secrets.DEPLOY_PATH }}/database/migrations/
            
            # 기존 마이그레이션 파일들을 순서대로 적용
            for migration_file in ${{ secrets.DEPLOY_PATH }}/database/migrations/*.sql; do
              if [ -f "$migration_file" ]; then
                echo "적용 중: $(basename "$migration_file")"
                docker exec -i mincenter-postgres psql -U mincenter -d mincenter < "$migration_file"
              fi
            done
            
            # 기존 파일들도 전송 (하위 호환성)
            scp ${{ github.workspace }}/database/seed.sql ${{ secrets.DEPLOY_PATH }}/database/
            scp ${{ github.workspace }}/database_data_dump.sql ${{ secrets.DEPLOY_PATH }}/database/
            
            echo "=== 데이터베이스 동기화 완료 ==="
      
      - name: Restart API after DB sync
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: 22
          script: |
            echo "=== API 재시작 (DB 변경으로 인해) ==="
            
            cd ${{ secrets.DEPLOY_PATH }}
            docker compose restart api
            
            # API 헬스체크
            sleep 10
            curl -f http://localhost:18080/health || echo "API 서비스 오류"
            
            echo "=== API 재시작 완료 ==="

  # 상태 확인
  health-check:
    needs: [deploy-site, deploy-admin, deploy-api, deploy-env, deploy-db]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Health check
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: 22
          script: |
            echo "=== 서비스 상태 확인 ==="
            
            # 컨테이너 상태
            cd ${{ secrets.DEPLOY_PATH }}
            docker compose ps
            
            # 헬스체크
            echo "API Health Check:"
            curl -f http://localhost:18080/health || echo "API 서비스 오류"
            
            echo "Site Health Check:"
            curl -f http://localhost:13000 || echo "Site 서비스 오류"
            
            echo "Admin Health Check:"
            curl -f http://localhost:13001 || echo "Admin 서비스 오류" 