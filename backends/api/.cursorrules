# 장애인 봉사단체 웹사이트 API - Cursor Rules

## 프로젝트 개요
장애인 봉사단체의 활동을 알리고 소식을 공유할 수 있는 웹사이트 백엔드 API 시스템
- 언어: Rust
- 프레임워크: Axum
- 데이터베이스: PostgreSQL
- 인증: JWT + OAuth 2.0
- 파일 저장: Local/S3

## 코딩 스타일 및 규칙

### 기본 원칙
- **안전성 우선**: unwrap() 사용 금지, Result<T, E> 패턴 사용
- **가독성**: 명확한 변수명과 함수명 사용
- **모듈화**: 기능별로 명확하게 분리
- **에러 처리**: 구체적이고 사용자 친화적인 에러 메시지
- **성능**: 불필요한 클론 방지, 효율적인 메모리 사용

### 네이밍 규칙
- **파일명**: snake_case (예: user_handler.rs, auth_middleware.rs)
- **함수명**: snake_case (예: create_user, get_post_by_id)
- **구조체**: PascalCase (예: User, PostResponse, CreatePostRequest)
- **상수**: SCREAMING_SNAKE_CASE (예: JWT_SECRET, MAX_FILE_SIZE)
- **변수**: snake_case (예: user_id, post_title)

### 프로젝트 구조
```
src/
├── main.rs                 # 애플리케이션 진입점
├── config/
│   ├── mod.rs
│   ├── app.rs             # 앱 설정
│   └── database.rs        # DB 설정
├── handlers/
│   ├── mod.rs
│   ├── auth.rs            # 인증 관련 핸들러
│   ├── users.rs           # 회원 관리
│   ├── boards.rs          # 게시판 관리
│   ├── posts.rs           # 게시글 관리
│   ├── comments.rs        # 댓글 관리
│   ├── files.rs           # 파일 관리
│   ├── galleries.rs       # 갤러리 관리
│   └── admin.rs           # 관리자 기능
├── models/
│   ├── mod.rs
│   ├── user.rs            # 사용자 모델
│   ├── post.rs            # 게시글 모델
│   ├── comment.rs         # 댓글 모델
│   ├── file.rs            # 파일 모델
│   └── response.rs        # 응답 모델
├── services/
│   ├── mod.rs
│   ├── auth_service.rs    # 인증 서비스
│   ├── user_service.rs    # 사용자 서비스
│   ├── post_service.rs    # 게시글 서비스
│   ├── file_service.rs    # 파일 서비스
│   └── email_service.rs   # 이메일 서비스
├── middleware/
│   ├── mod.rs
│   ├── auth.rs            # JWT 인증 미들웨어
│   ├── cors.rs            # CORS 설정
│   ├── rate_limit.rs      # 속도 제한
│   └── logging.rs         # 로깅 미들웨어
├── utils/
│   ├── mod.rs
│   ├── jwt.rs             # JWT 유틸리티
│   ├── validation.rs      # 입력 검증
│   ├── image.rs           # 이미지 처리
│   └── pagination.rs      # 페이징 유틸리티
├── database/
│   ├── mod.rs
│   ├── connection.rs      # DB 연결
│   └── migrations/        # 마이그레이션 파일
└── errors/
    ├── mod.rs
    └── app_error.rs       # 커스텀 에러 타입
```

## 핵심 기능 구현 가이드

### 1. 에러 처리
모든 에러는 사용자 친화적인 메시지와 함께 적절한 HTTP 상태 코드를 반환해야 함
```rust
#[derive(Debug, Clone, Serialize)]
pub struct ApiError {
    pub code: String,
    pub message: String,
    pub details: Option<serde_json::Value>,
}

impl ApiError {
    pub fn validation_error(message: &str) -> Self {
        Self {
            code: "VALIDATION_ERROR".to_string(),
            message: message.to_string(),
            details: None,
        }
    }
}
```

### 2. 응답 형식
모든 API 응답은 일관된 형식을 사용
```rust
#[derive(Debug, Serialize)]
pub struct ApiResponse<T> {
    pub success: bool,
    pub data: Option<T>,
    pub message: String,
    pub pagination: Option<PaginationInfo>,
}

#[derive(Debug, Serialize)]
pub struct PaginationInfo {
    pub page: u32,
    pub limit: u32,
    pub total: u64,
    pub total_pages: u32,
}
```

### 3. 데이터베이스 모델
```rust
#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]
pub struct User {
    pub id: Uuid,
    pub email: String,
    pub name: String,
    pub phone: Option<String>,
    pub profile_image: Option<String>,
    pub points: i32,
    pub role: UserRole,
    pub status: UserStatus,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]
#[sqlx(type_name = "user_role", rename_all = "snake_case")]
pub enum UserRole {
    User,
    Admin,
}
```

### 4. 요청/응답 DTO
```rust
#[derive(Debug, Deserialize, Validate)]
pub struct CreatePostRequest {
    #[validate(length(min = 1, max = 200))]
    pub title: String,
    #[validate(length(min = 1))]
    pub content: String,
    pub board_id: Uuid,
    pub is_notice: Option<bool>,
}

#[derive(Debug, Serialize)]
pub struct PostResponse {
    pub id: Uuid,
    pub title: String,
    pub content: String,
    pub author: UserSummary,
    pub board: BoardSummary,
    pub views: i32,
    pub likes: i32,
    pub files: Vec<FileInfo>,
    pub created_at: DateTime<Utc>,
}
```

### 5. 핸들러 패턴
```rust
pub async fn create_post(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(payload): Json<CreatePostRequest>,
) -> Result<Json<ApiResponse<PostResponse>>, ApiError> {
    // 입력 검증
    payload.validate().map_err(|e| ApiError::validation_error(&e.to_string()))?;
    
    // 서비스 계층 호출
    let post = post_service::create_post(&app_state.db, &claims.user_id, payload).await?;
    
    Ok(Json(ApiResponse {
        success: true,
        data: Some(post),
        message: "게시글이 성공적으로 작성되었습니다.".to_string(),
        pagination: None,
    }))
}
```

### 6. 미들웨어 구현
```rust
pub async fn auth_middleware(
    State(app_state): State<AppState>,
    mut request: Request,
    next: Next,
) -> Result<Response, ApiError> {
    let auth_header = request
        .headers()
        .get("Authorization")
        .and_then(|header| header.to_str().ok())
        .ok_or_else(|| ApiError::unauthorized("토큰이 필요합니다."))?;
    
    let token = auth_header.strip_prefix("Bearer ")
        .ok_or_else(|| ApiError::unauthorized("올바르지 않은 토큰 형식입니다."))?;
    
    let claims = jwt_utils::verify_token(token)?;
    request.extensions_mut().insert(claims);
    
    Ok(next.run(request).await)
}
```

## 특수 기능 구현 가이드

### 1. 임시저장 시스템
- Draft 모델과 Post 모델 분리
- 자동저장 스케줄러 구현
- 만료된 임시저장 정리 작업

### 2. 파일 업로드 및 처리
- 멀티파트 업로드 처리
- 이미지 리사이징 (image crate 사용)
- 썸네일 자동 생성
- WebP 변환

### 3. 실시간 기능
- Server-Sent Events (SSE) 사용
- 알림 시스템 구현
- 실시간 업로드 진행률

### 4. 소셜 로그인
- OAuth 2.0 플로우 구현
- 소셜 제공자별 핸들러
- 계정 연동 기능

## 보안 가이드라인

### 1. 인증 및 인가
- JWT 토큰 검증
- Role-based access control
- Rate limiting 적용

### 2. 입력 검증
- validator crate 사용
- SQL 인젝션 방지
- XSS 방지

### 3. 파일 업로드 보안
- 파일 타입 검증
- 파일 크기 제한
- EXIF 데이터 제거

## 성능 최적화

### 1. 데이터베이스
- 적절한 인덱스 설정
- 쿼리 최적화
- 커넥션 풀 사용

### 2. 캐싱
- Redis 사용
- 응답 캐싱
- 세션 저장

### 3. 비동기 처리
- 파일 처리 백그라운드 작업
- 이메일 발송 큐
- 배치 작업 스케줄링

## 테스트 가이드

### 1. 유닛 테스트
- 각 서비스 함수별 테스트
- 에러 케이스 포함
- Mock 데이터 사용

### 2. 통합 테스트
- API 엔드포인트 테스트
- 데이터베이스 트랜잭션 테스트
- 인증 플로우 테스트

## 필수 의존성

```toml
[dependencies]
axum = "0.7"
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "postgres", "uuid", "chrono"] }
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
jsonwebtoken = "9.0"
bcrypt = "0.15"
validator = { version = "0.18", features = ["derive"] }
tracing = "0.1"
tracing-subscriber = "0.3"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "fs"] }
anyhow = "1.0"
thiserror = "1.0"
config = "0.14"
redis = "0.24"
lettre = "0.11"
image = "0.24"
reqwest = { version = "0.11", features = ["json"] }
```

## 코드 품질 규칙

1. **clippy 경고 무시 금지**: 모든 clippy 경고 수정
2. **unsafe 코드 금지**: 특별한 경우가 아니면 사용 금지
3. **패닉 방지**: unwrap(), expect() 대신 적절한 에러 처리
4. **문서화**: public 함수와 구조체에 doc comment 필수
5. **테스트 커버리지**: 핵심 비즈니스 로직 80% 이상
6. **의존성 최소화**: 필요한 기능만 추가
7. **타입 안전성**: 가능한 한 컴파일 타임에 에러 확인

## API 응답 예시

### 성공 응답
```json
{
  "success": true,
  "data": {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "title": "봉사활동 후기"
  },
  "message": "요청이 성공적으로 처리되었습니다.",
  "pagination": {
    "page": 1,
    "limit": 10,
    "total": 100,
    "totalPages": 10
  }
}
```

### 에러 응답
```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "입력 데이터가 올바르지 않습니다.",
    "details": {
      "title": "제목은 필수입니다."
    }
  }
}
```

이 규칙들을 따라 안전하고 확장 가능한 Rust API를 개발하세요.

## 한글로 답변해주세요.